% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_model.R
\name{fit_model}
\alias{fit_model}
\title{Fit a curve with \code{incur}.}
\usage{
fit_model(
  .data,
  .x_var,
  .y_var,
  .curve_func,
  .start_func = NULL,
  .start_vals = NULL,
  .huber = FALSE,
  .detect_outliers = FALSE,
  .shared_group = NULL,
  .shared_params = NULL,
  .lower_bounds = NULL,
  .upper_bounds = NULL,
  .return_func = FALSE,
  ...
)
}
\arguments{
\item{.data}{A \code{data.frame} or \code{data.frame} extension (tibble) in long format.}

\item{.x_var}{An quoted/unquoted argument that refers to the the \code{x} value within \code{.data}.}

\item{.y_var}{An quoted/unquoted argument that refers to the the \code{y} value within \code{.data}.}

\item{.curve_func}{A function that describes a curve/model in terms of \code{x}. See \code{incur::incur_models} for common examples. Alternatively, see below for examples.}

\item{.start_func}{A function with arguments \code{x} and \code{y} that returns a named list of starting values for all arguments/parameters within \code{.curv_func}. See \code{incur::incur_models} for common examples. Alternatively, see below for example.}

\item{.start_vals}{A named list of starting values for all arguments/parameters within \code{curv_func}. This cannot be used in conjunction with \code{.detect_outliers}.}

\item{.huber}{Perform iterative reweighted least squares non-linear regression using the Huber loss function.}

\item{.detect_outliers}{Boolean to indicate whether to filter outliers as described in Motulsky and Brown (2006). It is highly recommended that the \code{.huber} argument is set to true in order to start with "robust" regression.}

\item{.shared_group}{For nested fits (shared parameters), the quoted/unquoted argument for the column in \code{.data} that refers to individual groups to share fitted parameters.}

\item{.shared_params}{For nested fits (shared parameters), a character vector that indicates which parameter(s) in \code{.curve_func} are to be shared across groups.}

\item{.lower_bounds}{A named list that contains the lower bounds for specified parameters. All other lower bounds will be set at \code{-Inf}.}

\item{.upper_bounds}{A named list that contains the upper bounds for specified parameters. All other upper bounds will be set at \code{Inf}.}

\item{.return_func}{For nested fits (shared parameters), a boolean to indicate whether to return a modified \code{.curve_func} used in this process.}

\item{...}{Other arguments to be passed to \code{minpack.lm::nlsLM}, such as \code{control} or \code{weights}.}
}
\value{
A named list containing:
\itemize{
\item \code{fit}: the fitted \code{nlsModel} object.
\item \code{data}: the original data used in the fit. If \code{.detect_outliers} is true then column added in the format \verb{outlier_\{y_var\}} will be added to indicate which points are detected as outliers.
}
@importFrom checkmate assert_character assert_data_frame assert_function assert_list assert_logical
@importFrom dplyr mutate relocate
@importFrom rlang is_null
@importFrom tidyr drop_na
}
\description{
Given a set of data, fit an curve via \code{minpack.lm} with options for shared parameters, bounds, and automated outlier detection and removal.
}
\examples{
# exponential plateau

# fit the curve to the data
# share y0 and k across state and force y0 > 0
# create data from each group
predicted <- map(unique(Puromycin$state), function(i) {
  # more data points = smoother curve
  # this is easier than a geom_function approach
  x_vals <- seq(min(fit$data$x), max(fit$data$x), length.out = 1e4)
  # create the data and return
  tibble(
    x = x_vals,
    y = predict(res$fit, newdata = tibble(x = x_vals, group = i)),
    group = i
  )
})
# collate
predicted <- bind_rows(predicted)
# plot
ggplot(mapping = aes(x, y, colour = group)) +
  geom_point(data = fit$data) +
  geom_line(data = predicted)
}
