% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_model.R
\name{fit_model}
\alias{fit_model}
\title{This the function used to fit}
\usage{
fit_model(
  .data,
  .x_var,
  .y_var,
  .curve_func,
  .start_func = NULL,
  .start_vals = NULL,
  .huber = FALSE,
  .detect_outliers = FALSE,
  .shared_group = NULL,
  .shared_params = NULL,
  .lower_bounds = NULL,
  .upper_bounds = NULL,
  .return_func = FALSE,
  ...
)
}
\arguments{
\item{.data}{A \code{data.frame} or \code{data.frame} extension (tibble) in long format.}

\item{.x_var}{An quoted/unquoted argument that refers to the the \code{x} value within \code{.data}.}

\item{.y_var}{An quoted/unquoted argument that refers to the the \code{y} value within \code{.data}.}

\item{.curve_func}{A function that describes a curve/model in terms of \code{x}. See below for examples.}

\item{.start_func}{A function with arguments \code{x} and \code{y} that returns a named list of starting values for all arguments/parameters within \code{.curv_func}. See below for examples.}

\item{.start_vals}{A named list of starting values for all arguments/parameters within \code{curv_func}. This cannot be used in conjunction with \code{.detect_outliers}.}

\item{.huber}{Perform iterative reweighted least squares non-linear regression using the Huber loss function.}

\item{.detect_outliers}{Boolean to indicate whether to filter outliers as described in Motulsky and Brown (2006). It is highly recommended that the \code{.huber} argument is set to true in order to start with "robust" regression.}

\item{.shared_group}{For nested fits (shared parameters), the quoted/unquoted argument for the column in \code{.data} that refers to individual groups to share fitted parameters.}

\item{.shared_params}{For nested fits (shared parameters), a character vector that indicates which parameter(s) in \code{.curve_func} are to be shared across groups.}

\item{.lower_bounds}{A named list that contains the lower bounds for specified parameters. All other lower bounds will be set at \code{-Inf}.}

\item{.upper_bounds}{A named list that contains the upper bounds for specified parameters. All other upper bounds will be set at \code{Inf}.}

\item{.return_func}{For nested fits (shared parameters), a boolean to indicate whether to return a modified \code{.curve_func} used in this process.}

\item{...}{Other arguments to be passed to \code{minpack.lm::nlsLM}, such as \code{control} or \code{weights}.}
}
\value{
A names list containing:
\itemize{
\item \code{fit}:the fitted \code{nlsModel} object
\item \code{data}: the original data with/without outlier column added in the format \verb{outlier_\{y_var\}}.
}
}
\description{
This the function used to fit
}
\examples{
# exponential plateau
func <- function(x, y0, ym, k) ym - (ym - y0) * exp(-k * x)
func_start <- function(x, y) list(ym = max(y), y0 = min(y), k = 1)

# fit the curve to the data
# share y0 and k across state and force y0 > 0
fit <- fit_model(
  .data = Puromycin,
  .x_var = conc,
  .y_var = rate,
  .curve_func = func,
  .start_func = func_start,
  .detect_outliers = TRUE,
  .lower_bounds = list(y0 = 0),
  .shared_group = state,
  .shared_params = c("y0", "k"),
  control = minpack.lm::nls.lm.control(maxiter = 1e3)
)
# create data from each group
predicted <- map(unique(Puromycin$state), function(i) {
  # more data points = smoother curve
  # this is easier than a geom_function approach
  x_vals <- seq(min(fit$data$x), max(fit$data$x), length.out = 1e4)
  # create the data and return
  tibble(
    x = x_vals,
    y = predict(res$fit, newdata = tibble(x = x_vals, group = i)),
    group = i
  )
})
# collate
predicted <- bind_rows(predicted)
# plot
ggplot(mapping = aes(x, y, colour = group)) +
  geom_point(data = fit$data) +
  geom_line(data = predicted)
}
